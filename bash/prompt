#!/bin/bash
# based on https://gist.github.com/robbles/2211471
# ‚ì• ‚éá ·ÉÑ ‚ëÇ êÄÄ œü «Ç ·ö† ‚Äß ‚óè ‚¶ø ‚Ä£ ‚úî ‚úò ‚úñ ‚òÖ Œû „Äí‚ÜØ ‚âà ‚Åñ ùë£ ‚Üµ 

# $1 is filename, echoes it going up dirs until $HOME but not including $HOME
_upfind() {
	dir=`pwd`
	while [[ $dir =~ ^$HOME/ ]]; do
		p=`find "$dir" -maxdepth 1 -name $1`
		if [ ! -z $p ]; then
			echo "$p"
			return
		fi
		dir=`dirname "$dir"`
	done
}

_virtualenv_auto_activate() {
	# Deactivate if venv dir no longer exists OR not prefix of pwd
	if [ "$VIRTUAL_ENV" ]; then
		base=$(basename $VIRTUAL_ENV)
		if [[ ! -d $VIRTUAL_ENV ]] || [[ ! $PWD/ =~ ^$(dirname $VIRTUAL_ENV)/ ]]; then
			msg="Deactivating virtualenv"
			deactivate
			unset _VENV_PATH
		fi
	fi

	# Check for symlink pointing to virtualenv
	if [ -L ".venv" ]; then
		# could be absolute or relative link, but the pwd is valid since we are in chpwd
		dir=`dirname $(readlink .venv)`
		base=`basename $(readlink .venv)`
		[ "$dir" = "." ] \
			&& _VENV_PATH="$(pwd -P)/$base" \
			|| _VENV_PATH="$(cd $dir >/dev/null && pwd -P)/$base"

	elif [ -d "venv" ]; then
		_VENV_PATH=$(pwd -P)/venv

	else
		_d=$(_upfind venv)
		[ -n "$_d" ] && _VENV_PATH=$_d
	fi

	# Check to see if already activated to avoid redundant activating
	if [[ -n $_VENV_PATH && $VIRTUAL_ENV != $_VENV_PATH ]]; then
		_VENV_NAME=$(basename `pwd`)
		VIRTUAL_ENV_DISABLE_PROMPT=1
		msg="Activating virtualenv"
		source $_VENV_PATH/bin/activate
	fi
	#[ "$msg" ] && echo "$(tput bold)$msg$(tput sgr0)"
}

_java_set_home() {
	local vers=$1
	if [ "$(uname -s)" = "Darwin" ]; then
		[[ "$vers" != "1.8.0" ]] && vers="-$vers"
		local dir=`ls -dt /Library/Java/JavaVirtualMachines/jdk${vers}* | head -1`
		dir=${dir}Contents/Home
		[ -d "$dir" ] && JAVA_HOME=$dir
	elif [ "$(uname -s)" = "Linux" ]; then
		local dir="/usr/lib/jvm/java-${vers}-openjdk"
		[ -d "$dir" ] && JAVA_HOME=$dir
	fi
	if [[ -d $JAVA_HOME ]]; then
		msg="Setting JAVA_HOME=${JAVA_HOME}"
		export JAVA_HOME
	else
		unset JAVA_HOME
		echo "Error: JAVA_HOME could not be set"
	fi
}
_java_auto_activate() {
	unset msg

	# unset if PWD (common parent) is parent of JSET_PATH
	if [[  -n $JSET_PATH && -n $JAVA_HOME ]]; then
		local common_parent=$(printf "%s\n%s\n" "$JSET_PATH" "$PWD" | sed -e 'N;s/^\(.*\).*\n\1.*$/\1/')
		if [[  ! $common_parent =~ ^$JSET_PATH ]]; then
			msg="Unsetting JAVA_HOME"
			unset JAVA_HOME && unset JSET_PATH
			if [[ -n $JSET_OLD_PATH ]]; then
				export PATH=$JSET_OLD_PATH
				unset JSET_OLD_PATH
			fi
		fi
	fi

	local java12=$(_upfind .java12)
	local java11=$(_upfind .java11)
	local java8=$(_upfind .java8)
	# if both then down (longer) dir has precedence; if both are same dir then use later
	if [[ -e $java12 && -e $java11 ]]; then
		[[ $(dirname $java12) =~ ^$(dirname $java11) ]] && unset java11 || unset java12
	fi
	if [[ -e $java11 && -e $java8 ]]; then
		[[ $(dirname $java11) =~ ^$(dirname $java8) ]] && unset java8 || unset java11
	fi
	if [[ -e $java12 && -e $java8 ]]; then
		[[ $(dirname $java12) =~ ^$(dirname $java8) ]] && unset java8 || unset java12
	fi
	[[ $java12 ]] && local dir=$(dirname $java12) && local vers='12'
	[[ $java11 ]] && local dir=$(dirname $java11) && local vers='11'
	[[ $java8 ]]  && local dir=$(dirname $java8)  && local vers='1.8.0'

	# if $dir is newer (JSET_PATH is parent of $dir) then unset
	if [[ $dir =~ ^$JSET_PATH/ ]]; then
		unset JAVA_HOME && unset JSET_PATH
	fi

	if [[ -n $dir && -z "$JAVA_HOME" ]]; then
		JSET_PATH=$dir
		_java_set_home $vers

		if [ "$(uname -s)" = "Linux" ]; then
			if [[ -n $JSET_OLD_PATH ]]; then
				PATH=$JSET_OLD_PATH
			fi
			JSET_OLD_PATH=$PATH
			export PATH=$JAVA_HOME/bin:$PATH
		fi
	fi

	[ "$msg" ] && echo "$(tput bold)$msg$(tput sgr0)"
}

_pwdtail() { #returns the last 2 fields of the working directory
	pwd|awk -F/ '{nlast = NF -1;print $nlast"/"$NF}'
}

_relpath0() {
	# path from $2 to $1
	python -c 'import os.path, sys; print(os.path.relpath(sys.argv[1],sys.argv[2]))' "$1" "${2-$PWD}"
}
_relpath() {
	# https://stackoverflow.com/questions/2564634/convert-absolute-path-into-relative-path-given-a-current-directory-using-bash/12498485#12498485
	# opposite param order as _relpath0, ie path from $1 to $2
	[ $# -ge 1 ] && [ $# -le 2 ] || return 1
	current="${2:+"$1"}"
	target="${2:-"$1"}"
	[ "$target" != . ] || target=/
	target="/${target##/}"
	[ "$current" != . ] || current=/
	current="${current:="/"}"
	current="/${current##/}"
	appendix="${target##/}"
	relative=''
	while appendix="${target#"$current"/}"
		[ "$current" != '/' ] && [ "$appendix" = "$target" ]; do
		if [ "$current" = "$appendix" ]; then
			relative="${relative:-.}"
			echo "${relative#/}"
			return 0
		fi
		current="${current%/*}"
		relative="$relative${relative:+/}.."
	done
	relative="$relative${relative:+${appendix:+/}}${appendix#/}"
	echo "$relative"
}

# https://gist.github.com/laggardkernel/6cb4e1664574212b125fbfd115fe90a4
_chpwd_hook() {
  shopt -s nullglob

  local f

  # run commands in CHPWD_COMMAND variable on dir change
  if [[ "$PREVPWD" != "$PWD" ]]; then
    local IFS=$';'
    for f in $CHPWD_COMMAND; do
      "$f"
    done
    unset IFS
  fi
  # refresh last working dir record
  export PREVPWD="$PWD"
}

_prompt_command() {
	code=$?

	# bash stores history in mem and writes it at exit but we want shared history b/ all shells:
	# -a Append the 'new' history lines to the history file. These are history lines entered since
	#    the beginning of the current bash session, but not already appended to the history file.
	# -c Clear the history list by deleting all the entries.
	# -r Read the contents of the history file and append them to the current history list.
	history -a
	history -c
	history -r

	# set for PS1 below
	ERR=
	IDENT=
	BRANCH=
	JOBS=

	local GREEN="\[\033[0;32m\]"
	local CYAN="\[\033[0;36m\]"
	local BCYAN="\[\033[1;36m\]"
	local BLUE="\[\033[0;34m\]"
	local GRAY="\[\033[0;37m\]"
	local DKGRAY="\[\033[1;30m\]"
	local WHITE="\[\033[1;37m\]"
	local RED="\[\033[0;31m\]"
	local YELLOW="\[\033[0;33m\]"
	local BRIGHT="\[\033[38;5;206m\]"
	# return color to Terminal setting for text color
	local DEFAULT="\[\033[0;39m\]"

	dots='‚óè‚óè‚óè'
	if [ $code -ne 0 ]; then
		ERR='${code}‚Üµ '
	fi
	if [ "$SESSION_TYPE" == "remote/ssh" ]; then
		IDENT='[\u@\h] '
		#dots="${CYAN}‚¶ø‚¶ø‚¶ø"
		dots="${CYAN}${dots}"
	fi
	if [ "\$(type -t __git_ps1)" ]; then
		BRANCH="\$(__git_ps1 '‚ÜØ\[$(tput sitm)\]%s\[$(tput ritm)\] ')"
	fi
	if [ "$(jobs -p)" ]; then
		JOBS="[\j]"
	fi

	if [[ "$PREVPWD" != "$PWD" ]]; then
		VENV=
		_virtualenv_auto_activate
		if [[ -n $VIRTUAL_ENV ]]; then
			local _h=$(dirname $VIRTUAL_ENV)
			local _t=$(basename $VIRTUAL_ENV)
			p="$(_relpath $PWD $_h)"
			[ "$p" = "." ] && p="" || p="$p/"
			p="$p$_t"
			VENV="(\[$(tput sitm)\]$p\[$(tput ritm)\]) "
		fi

		_java_auto_activate
	fi

	# set the titlebar to the last 2 fields of pwd
	local _u=''
	if [ "$SESSION_TYPE" == "remote/ssh" ]; then
		_u="${USER}@"
	fi
	echo -ne "\033]0;[${_u}$(hostname -s)] ${PWD##*/}\007"

	export PS1="${RED}${ERR}${BRIGHT}${dots} \
${BLUE}${IDENT}${GREEN}${BRANCH}${BLUE}${VENV}\
${YELLOW}\w${BCYAN}${JOBS}${DEFAULT}\$ "
}

# either: 1) if [[ "$PREVPWD" != "$PWD" ]]; then .. (in _prompt_command)
#     or: 2) append the command into CHPWD_COMMAND, see _chpwd_hook() above
#CHPWD_COMMAND="${CHPWD_COMMAND:+$CHPWD_COMMAND;}_some_bash_fn"

PROMPT_COMMAND="_prompt_command; _chpwd_hook; ${PROMPT_COMMAND:+$PROMPT_COMMAND}"
